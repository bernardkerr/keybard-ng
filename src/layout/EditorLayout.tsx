import * as React from "react";

import { SidebarProvider, useSidebar } from "@/components/ui/sidebar";
import { PanelsProvider, usePanels } from "@/contexts/PanelsContext";
import { DragProvider, useDrag, DragItem } from "@/contexts/DragContext";
import { DragOverlay } from "@/components/DragOverlay";
import SecondarySidebar, { DETAIL_SIDEBAR_WIDTH } from "./SecondarySidebar/SecondarySidebar";
import { BottomPanel, BOTTOM_PANEL_HEIGHT } from "./BottomPanel";
import BindingEditorContainer from "./SecondarySidebar/components/BindingEditor/BindingEditorContainer";


import { useVial } from "@/contexts/VialContext";
import { cn } from "@/lib/utils";
import LayerSelector from "./LayerSelector";
import KeyboardViewInstance from "./KeyboardViewInstance";
import LayersPlusIcon from "@/components/icons/LayersPlusIcon";
import LayersMinusIcon from "@/components/icons/LayersMinusIcon";
import AppSidebar from "./Sidebar";

import { LayerProvider, useLayer } from "@/contexts/LayerContext";
import { useLayoutLibrary } from "@/contexts/LayoutLibraryContext";
import { PasteLayerDialog } from "@/components/PasteLayerDialog";

import { LayoutSettingsProvider, useLayoutSettings } from "@/contexts/LayoutSettingsContext";
import { UNIT_SIZE, SVALBOARD_LAYOUT } from "@/constants/svalboard-layout";
import { THUMB_OFFSET_U, MAX_FINGER_CLUSTER_SQUEEZE_U } from "@/constants/keyboard-visuals";

import { useKeyBinding } from "@/contexts/KeyBindingContext";
import { useChanges } from "@/hooks/useChanges";
// import { PanelBottom, PanelRight, X } from "lucide-react";
import { X } from "lucide-react";
import { Tooltip, TooltipContent, TooltipTrigger } from "@/components/ui/tooltip";

import { MatrixTester } from "@/components/MatrixTester";
import { MATRIX_COLS } from "@/constants/svalboard-layout";
import EditorSidePanel, { PickerMode } from "./SecondarySidebar/components/EditorSidePanel";
import { InfoPanelWidget } from "@/components/InfoPanelWidget";
import { EditorControls } from "./EditorControls";

const EditorLayout = () => {
    const { assignKeycodeTo } = useKeyBinding();

    const handleUnhandledDrop = React.useCallback((item: DragItem) => {
        if (item.row !== undefined && item.col !== undefined && item.layer !== undefined) {
            console.log("Unhandled drop for keyboard key, assigning KC_NO", item);
            assignKeycodeTo({
                type: "keyboard",
                row: item.row,
                col: item.col,
                layer: item.layer
            }, "KC_NO");
        }
    }, [assignKeycodeTo]);

    return (
        <SidebarProvider defaultOpen={false}>
            <PanelsProvider>
                <LayoutSettingsProvider>
                    <LayerProvider>
                        <DragProvider onUnhandledDrop={handleUnhandledDrop}>
                            <EditorLayoutInner />
                            <DragOverlay />
                        </DragProvider>
                    </LayerProvider>
                </LayoutSettingsProvider>
            </PanelsProvider>
        </SidebarProvider>
    );
};

const EditorLayoutInner = () => {
    const { keyboard, setKeyboard, updateKey /*, resetToOriginal*/ } = useVial();
    const { selectedLayer, setSelectedLayer } = useLayer();
    const { clearSelection } = useKeyBinding();
    const { keyVariant, layoutMode, setSecondarySidebarOpen, setPrimarySidebarExpanded, registerPrimarySidebarControl, setMeasuredDimensions, is3DMode, fingerClusterSqueeze } = useLayoutSettings();
    const { layerClipboard, copyLayer, openPasteDialog } = useLayoutLibrary();
    const { isDragging, draggedItem, markDropConsumed } = useDrag();

    const KC_TRNS = 1;
    // Track if we're dragging a layer over the keyboard area
    const [isLayerDragOver, setIsLayerDragOver] = React.useState(false);
    const isDraggingLayer = isDragging && draggedItem?.type === "layer" && draggedItem?.component === "Layer";

    // Dynamic view instances for stacking keyboard views
    interface ViewInstance {
        id: string;
        selectedLayer: number;
    }
    const [viewInstances, setViewInstances] = React.useState<ViewInstance[]>([
        { id: "primary", selectedLayer: 0 }
    ]);
    const [showAllLayers, setShowAllLayers] = React.useState(true);
    const [isMultiLayersActive, setIsMultiLayersActive] = React.useState(false);
    const [isLayerOrderReversed, setIsLayerOrderReversed] = React.useState(false);
    const [layerSpacingAdjust, setLayerSpacingAdjust] = React.useState(410);
    const [baseBadgeOffsetY, setBaseBadgeOffsetY] = React.useState<number | null>(null);
    // UI-only layer on/off state. TODO: replace with device-provided layer state when available.
    const [layerActiveState, setLayerActiveState] = React.useState<boolean[]>([]);
    const [transparencyByLayer, setTransparencyByLayer] = React.useState<Record<number, boolean>>({});
    const [isAllTransparencyActive, setIsAllTransparencyActive] = React.useState(false);
    const [isTransparencyRestoring, setIsTransparencyRestoring] = React.useState(false);
    const transparencyBackupRef = React.useRef<Record<number, boolean> | null>(null);
    const viewsScrollRef = React.useRef<HTMLDivElement>(null);
    const layerViewRefs = React.useRef<Map<number, HTMLDivElement>>(new Map());
    let nextViewId = React.useRef(1);

    // Animation: flying icon between layers-plus and layers-minus
    const addViewButtonRef = React.useRef<HTMLButtonElement>(null);
    const [flyingIcon, setFlyingIcon] = React.useState<{
        startX: number; startY: number;
        endX?: number; endY?: number;
        iconType: 'plus' | 'minus';
    } | null>(null);
    const pendingTargetId = React.useRef<string | null>(null);
    const pendingRemoveId = React.useRef<string | null>(null);
    const [revealingViewId, setRevealingViewId] = React.useState<string | null>(null);
    const [hidingViewId, setHidingViewId] = React.useState<string | null>(null);
    const [hideAddButton, setHideAddButton] = React.useState(false);
    const animationTimerRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);

    // Clean up animation timer on unmount
    React.useEffect(() => {
        return () => {
            if (animationTimerRef.current) clearTimeout(animationTimerRef.current);
        };
    }, []);

    // Initialize or resize layer "isActive" state when keyboard layer count changes.
    // TODO: if/when the keyboard reports layer-on state, hydrate from that source instead.
    React.useEffect(() => {
        if (!keyboard) return;
        const totalLayers = keyboard.layers || 16;
        setLayerActiveState(prev => {
            if (!prev || prev.length === 0) {
                return Array.from({ length: totalLayers }, (_, i) => i === 0);
            }
            if (prev.length === totalLayers) return prev;
            const next = Array.from({ length: totalLayers }, (_, i) => {
                const existing = prev[i];
                if (existing === undefined) return i === 0;
                return existing;
            });
            return next;
        });
    }, [keyboard]);

    const handleAddView = React.useCallback(() => {
        const newId = `secondary-${nextViewId.current++}`;

        // Capture start position of the layers-plus button
        const rect = addViewButtonRef.current?.getBoundingClientRect();
        if (rect) {
            setFlyingIcon({ startX: rect.left, startY: rect.top, iconType: 'plus' });
            pendingTargetId.current = newId;
        }

        // Hide the add button and view until halfway through animation
        setHideAddButton(true);
        setRevealingViewId(newId);
        setViewInstances(prev => {
            const lastView = prev[prev.length - 1];
            const totalLayers = keyboard?.layers || 16;
            const nextLayer = lastView ? (lastView.selectedLayer + 1) % totalLayers : 0;
            return [...prev, { id: newId, selectedLayer: nextLayer }];
        });
    }, [keyboard?.layers]);

    // After the new view renders, find the layers-minus button and start the transition
    React.useEffect(() => {
        if (!flyingIcon || flyingIcon.endX !== undefined || !pendingTargetId.current) return;
        // Double rAF ensures DOM is painted before querying
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                const target = document.querySelector(`[data-remove-view="${pendingTargetId.current}"]`);
                if (target) {
                    const targetRect = target.getBoundingClientRect();
                    setFlyingIcon(prev => prev ? {
                        ...prev,
                        endX: targetRect.left,
                        endY: targetRect.top,
                    } : null);
                    // Reveal view and add button at halfway point of the 400ms transition
                    animationTimerRef.current = setTimeout(() => {
                        setRevealingViewId(null);
                        setHideAddButton(false);
                    }, 200);
                } else {
                    // Target not found, reveal immediately
                    setFlyingIcon(null);
                    setRevealingViewId(null);
                    setHideAddButton(false);
                }
                pendingTargetId.current = null;
            });
        });
    }, [flyingIcon, viewInstances]);

    const handleRemoveView = React.useCallback((id: string) => {
        // Capture positions before any state changes
        const minusBtn = document.querySelector(`[data-remove-view="${id}"]`);
        const plusBtn = addViewButtonRef.current;

        if (minusBtn && plusBtn) {
            const minusRect = minusBtn.getBoundingClientRect();
            const plusRect = plusBtn.getBoundingClientRect();

            // Hide view and add button immediately, then animate icon horizontally back to plus
            setHideAddButton(true);
            setHidingViewId(id);
            pendingRemoveId.current = id;
            setFlyingIcon({ startX: minusRect.left, startY: minusRect.top, iconType: 'minus' });

            // Set end position after DOM paints the start position
            // Only animate X (horizontal), keep same Y since plus button will end up on this row
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    setFlyingIcon(prev => prev ? {
                        ...prev,
                        endX: plusRect.left,
                        endY: prev.startY, // horizontal only
                    } : null);
                    // Remove view and show add button at halfway point of the 400ms transition
                    animationTimerRef.current = setTimeout(() => {
                        setViewInstances(prev => prev.filter(v => v.id !== pendingRemoveId.current));
                        setHidingViewId(null);
                        setHideAddButton(false);
                        pendingRemoveId.current = null;
                    }, 200);
                });
            });
        } else {
            // Fallback: remove immediately
            setViewInstances(prev => prev.filter(v => v.id !== id));
        }
    }, []);

    // Clean up flying icon when animation completes
    const handleFlyingIconEnd = React.useCallback(() => {
        setFlyingIcon(null);
    }, []);

    const handleToggleShowLayers = React.useCallback(() => {
        setShowAllLayers(prev => !prev);
    }, []);

    const handleSetViewLayer = React.useCallback((id: string, layer: number) => {
        setViewInstances(prev => prev.map(v =>
            v.id === id ? { ...v, selectedLayer: layer } : v
        ));
        // Always sync LayerContext so sidebar panels reflect the last-interacted view
        setSelectedLayer(layer);
    }, [setSelectedLayer]);

    React.useEffect(() => {
        setViewInstances(prev => prev.map(v =>
            v.id === "primary" && v.selectedLayer !== selectedLayer
                ? { ...v, selectedLayer }
                : v
        ));
    }, [selectedLayer]);

    // UI toggle for layer on/off. TODO: when hardware supports this, send the command
    // and update state from the device response instead of flipping locally.
    const handleToggleLayerOn = React.useCallback((layerIndex: number) => {
        setLayerActiveState(prev => {
            const totalLayers = keyboard?.layers || 16;
            const base = prev.length > 0
                ? [...prev]
                : Array.from({ length: totalLayers }, (_, i) => i === 0);
            if (base.length < totalLayers) {
                for (let i = base.length; i < totalLayers; i++) {
                    base[i] = i === 0;
                }
            }
            base[layerIndex] = !base[layerIndex];
            return base;
        });
    }, [keyboard?.layers]);

    const handleToggleTransparency = React.useCallback((layerIndex: number, next: boolean) => {
        setTransparencyByLayer(prev => ({ ...prev, [layerIndex]: next }));
    }, []);

    const handleToggleAllTransparency = React.useCallback(() => {
        const next = !isAllTransparencyActive;
        const totalLayers = keyboard?.layers || 16;
        if (next) {
            transparencyBackupRef.current = { ...transparencyByLayer };
            const allOn = Array.from({ length: totalLayers }, (_, i) => i)
                .reduce<Record<number, boolean>>((acc, layerIndex) => {
                    acc[layerIndex] = true;
                    return acc;
                }, {});
            setTransparencyByLayer(allOn);
        } else {
            setIsTransparencyRestoring(true);
            setTransparencyByLayer(transparencyBackupRef.current || {});
            transparencyBackupRef.current = null;
        }
        setIsAllTransparencyActive(next);
        if (!next) {
            requestAnimationFrame(() => {
                setIsTransparencyRestoring(false);
            });
        }
    }, [isAllTransparencyActive, keyboard?.layers, transparencyByLayer]);

    const handleGhostNavigate = React.useCallback((sourceLayer: number) => {
        const targetEl = layerViewRefs.current.get(sourceLayer);
        const container = viewsScrollRef.current;
        if (targetEl && container) {
            const top = targetEl.offsetTop;
            container.scrollTo({ top, behavior: "smooth" });
        }
        setSelectedLayer(sourceLayer);
    }, [setSelectedLayer]);
    const primaryLayerIndex = isMultiLayersActive
        ? selectedLayer
        : (viewInstances.find(v => v.id === "primary")?.selectedLayer ?? selectedLayer);

    const primaryView = React.useMemo(
        () => ({ id: "primary", selectedLayer: primaryLayerIndex }),
        [primaryLayerIndex]
    );

    const multiLayerIds = React.useMemo(() => {
        if (!keyboard) return [] as number[];
        const totalLayers = keyboard.layers || 16;

        if (showAllLayers) {
            return Array.from({ length: totalLayers }, (_, i) => i);
        }

        const keymap = keyboard.keymap || [];
        return Array.from({ length: totalLayers }, (_, i) => i).filter((layerIndex) => {
            const layerData = keymap[layerIndex];
            const isTransparentLayer = layerData ? layerData.every((keycode) => keycode === KC_TRNS) : true;
            return !isTransparentLayer || layerIndex === primaryLayerIndex;
        });
    }, [keyboard, showAllLayers, primaryLayerIndex]);

    // In 3D multilayer mode, we keep ordering identical to 2D multilayer.

    const renderedViews = React.useMemo(() => {
        if (!isMultiLayersActive) {
            return viewInstances;
        }
        const extraLayers = multiLayerIds.filter(layerIndex => layerIndex !== primaryLayerIndex);
        const orderedExtras = isLayerOrderReversed ? [...extraLayers].reverse() : extraLayers;
        return [
            primaryView,
            ...orderedExtras.map(layerIndex => ({
                id: `multi-${layerIndex}`,
                selectedLayer: layerIndex
            }))
        ];
    }, [isMultiLayersActive, primaryView, multiLayerIds, isLayerOrderReversed, primaryLayerIndex]);

    // Badge positioning handled per-layer in KeyboardViewInstance to keep layout/badge relationship consistent.

    // Ref for measuring container dimensions
    const contentContainerRef = React.useRef<HTMLDivElement>(null);

    // Use dynamic keylayout if available, otherwise fallback to hardcoded layout
    const keyboardLayout = React.useMemo(() => (
        (keyboard?.keylayout && Object.keys(keyboard.keylayout).length > 0)
            ? keyboard.keylayout as Record<number, { x: number; y: number; w: number; h: number }>
            : SVALBOARD_LAYOUT
    ), [keyboard]);

    // Calculate keyboard layout extents (independent of current keyVariant)
    const keyboardExtents = React.useMemo(() => {
        if (!keyboard) return { maxX: 20, maxY: 10 }; // default estimate

        const useFragmentLayout = keyboard.keylayout && Object.keys(keyboard.keylayout).length > 0;

        // Find max X and Y extents
        let maxX = 0;
        let maxY = 0;
        Object.values(keyboardLayout).forEach((key) => {
            // Only apply THUMB_OFFSET_U for hardcoded layout, not fragment-composed layouts
            const yPos = (!useFragmentLayout && key.y >= 6) ? key.y + THUMB_OFFSET_U : key.y;
            maxX = Math.max(maxX, key.x + key.w);
            maxY = Math.max(maxY, yPos + key.h);
        });

        return { maxX, maxY };
    }, [keyboard]);

    // Current key unit size based on variant
    const currentUnitSize = React.useMemo(() =>
        keyVariant === 'small' ? 30 : keyVariant === 'medium' ? 45 : UNIT_SIZE,
        [keyVariant]);

    // Track container height for dynamic spacing
    const [containerHeight, setContainerHeight] = React.useState(0);


    // Raw keyboard widths without squeeze (used for squeeze calculation)
    const rawKeyboardWidths = React.useMemo(() => ({
        default: keyboardExtents.maxX * UNIT_SIZE + 32, // +32 for padding
        medium: keyboardExtents.maxX * 45 + 32,
        small: keyboardExtents.maxX * 30 + 32,
    }), [keyboardExtents]);

    // Calculate keyboard widths at each size (for auto-sizing)
    // Account for max squeeze capability - both sides can squeeze toward center
    const squeezeReduction = 2 * MAX_FINGER_CLUSTER_SQUEEZE_U;
    const keyboardWidths = React.useMemo(() => ({
        default: rawKeyboardWidths.default, // no squeeze at default
        medium: (keyboardExtents.maxX - squeezeReduction) * 45 + 32, // squeeze enabled
        small: rawKeyboardWidths.small, // no squeeze at small (already compact)
    }), [keyboardExtents, squeezeReduction, rawKeyboardWidths]);

    // Calculate keyboard heights at each size (for auto-sizing)
    const keyboardHeights = React.useMemo(() => ({
        default: keyboardExtents.maxY * UNIT_SIZE + 80, // +80 for layer selector and bottom bar
        medium: keyboardExtents.maxY * 45 + 80,
        small: keyboardExtents.maxY * 30 + 80,
    }), [keyboardExtents]);

    // Measure container dimensions and report to context for auto-sizing
    React.useEffect(() => {
        const container = contentContainerRef.current;
        if (!container) return;

        const measureSpace = () => {
            const containerWidth = container.clientWidth;
            const height = container.clientHeight;

            // Track container height for dynamic spacing
            setContainerHeight(height);

            // Report measured dimensions to context for auto-sizing
            setMeasuredDimensions({
                containerWidth,
                containerHeight: height,
                keyboardWidths,
                keyboardHeights,
                rawKeyboardWidths,
            });
        };

        // Initial measurement
        measureSpace();

        // Set up ResizeObserver for dynamic updates
        const resizeObserver = new ResizeObserver(measureSpace);
        resizeObserver.observe(container);

        return () => resizeObserver.disconnect();
    }, [keyboardWidths, keyboardHeights, rawKeyboardWidths, setMeasuredDimensions]);


    const { queue } = useChanges();

    // Ctrl+V handler for pasting layers
    React.useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            // Check for Ctrl+V (or Cmd+V on Mac)
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                // Only handle if we have a layer in clipboard
                if (layerClipboard) {
                    e.preventDefault();
                    openPasteDialog();
                }
            }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [layerClipboard, openPasteDialog]);

    // Handler for when paste is confirmed
    const handlePasteConfirm = React.useCallback(() => {
        if (!keyboard || !layerClipboard || !keyboard.keymap) return;

        const sourceKeymap = layerClipboard.layer.keymap;
        const sourceLayerColor = layerClipboard.layer.layerColor;
        const sourceLedColor = layerClipboard.layer.ledColor;
        const targetLayerKeymap = keyboard.keymap[selectedLayer] || [];
        const cols = keyboard.cols || MATRIX_COLS;

        // Create ONE copy and batch all changes to avoid React state batching issues
        const updatedKeyboard = JSON.parse(JSON.stringify(keyboard));
        if (!updatedKeyboard.keymap[selectedLayer]) {
            updatedKeyboard.keymap[selectedLayer] = [];
        }

        // Copy cosmetic layer color if the source layer has one
        if (sourceLayerColor) {
            if (!updatedKeyboard.cosmetic) {
                updatedKeyboard.cosmetic = {};
            }
            if (!updatedKeyboard.cosmetic.layer_colors) {
                updatedKeyboard.cosmetic.layer_colors = {};
            }
            updatedKeyboard.cosmetic.layer_colors[selectedLayer] = sourceLayerColor;
        }

        // Copy LED hardware color if the source layer has one
        if (sourceLedColor) {
            if (!updatedKeyboard.layer_colors) {
                updatedKeyboard.layer_colors = [];
            }
            // Ensure array is long enough
            while (updatedKeyboard.layer_colors.length <= selectedLayer) {
                updatedKeyboard.layer_colors.push({ hue: 0, sat: 0, val: 0 });
            }
            updatedKeyboard.layer_colors[selectedLayer] = { ...sourceLedColor };
        }

        // Collect all changes and apply to the single copy
        for (let i = 0; i < targetLayerKeymap.length && i < sourceKeymap.length; i++) {
            const row = Math.floor(i / cols);
            const col = i % cols;
            const newValue = sourceKeymap[i];
            const currentValue = targetLayerKeymap[i];
            const matrixPos = row * cols + col;

            if (newValue !== currentValue) {
                // Apply to the single copy
                updatedKeyboard.keymap[selectedLayer][matrixPos] = newValue;

                // Queue change for push to device
                const changeDesc = `key_${selectedLayer}_${row}_${col}`;
                queue(
                    changeDesc,
                    async () => {
                        await updateKey(selectedLayer, row, col, newValue);
                    },
                    {
                        type: "key",
                        layer: selectedLayer,
                        row,
                        col,
                        keycode: newValue,
                        previousValue: currentValue,
                    }
                );
            }
        }

        // Update state ONCE with all changes
        setKeyboard(updatedKeyboard);
    }, [keyboard, layerClipboard, selectedLayer, queue, updateKey, setKeyboard]);

    // Handle layer drop on keyboard area
    const handleLayerDrop = React.useCallback(() => {
        if (!isDraggingLayer || !draggedItem?.layerData) return;

        // Copy the layer to clipboard and open paste dialog
        copyLayer(draggedItem.layerData);
        markDropConsumed();

        // Open paste dialog after a brief delay to ensure clipboard is set
        setTimeout(() => openPasteDialog(), 0);
    }, [isDraggingLayer, draggedItem, copyLayer, markDropConsumed, openPasteDialog]);

    // Get current layer name for the paste dialog
    const currentLayerName = React.useMemo(() => {
        if (!keyboard?.cosmetic?.layer) return `Layer ${selectedLayer}`;
        return keyboard.cosmetic.layer[String(selectedLayer)] || `Layer ${selectedLayer}`;
    }, [keyboard, selectedLayer]);



    const primarySidebar = useSidebar("primary-nav", { defaultOpen: false });
    const { isMobile, state, activePanel, itemToEdit, setItemToEdit, handleCloseEditor } = usePanels();

    // Editor overlay state for bottom bar mode
    const [pickerMode, setPickerMode] = React.useState<PickerMode>("keyboard");
    const [isClosingEditor, setIsClosingEditor] = React.useState(false);

    // Check if we should show the editor overlay in bottom bar mode
    const showEditorOverlay = layoutMode === "bottombar" && itemToEdit !== null &&
        ["tapdances", "combos", "macros", "overrides", "altrepeat", "leaders"].includes(activePanel || "");

    // Reset picker mode when editor closes
    React.useEffect(() => {
        if (!showEditorOverlay) {
            const timeout = setTimeout(() => setPickerMode("keyboard"), 500);
            return () => clearTimeout(timeout);
        }
    }, [showEditorOverlay]);

    const [showInfoPanel, setShowInfoPanel] = React.useState(false);
    const [gitBranchLabel, setGitBranchLabel] = React.useState<string>(__GIT_BRANCH__);

    React.useEffect(() => {
        if (itemToEdit === null) setIsClosingEditor(false);
    }, [itemToEdit]);

    React.useEffect(() => {
        if (!import.meta.env.DEV) return;
        let isMounted = true;
        fetch("/__git_branch")
            .then(res => res.json())
            .then(data => {
                if (isMounted && data?.branch) {
                    setGitBranchLabel(String(data.branch));
                }
            })
            .catch(() => undefined);
        return () => {
            isMounted = false;
        };
    }, []);

    // Layout mode determines whether we use sidebar or bottom panel
    const useSidebarLayout = layoutMode === "sidebar";
    const useBottomLayout = layoutMode === "bottombar";

    const primaryOffset = primarySidebar.isMobile ? undefined : primarySidebar.state === "collapsed" ? "var(--sidebar-width-icon)" : "var(--sidebar-width-base)";

    // In sidebar mode: show detail sidebar on right
    // In bottom bar mode: no detail sidebar, use bottom panel instead
    const showDetailsSidebar = useSidebarLayout && !isMobile && state === "expanded";
    const showBottomPanel = useBottomLayout && state === "expanded";

    // Notify context when a panel is selected (wants to be shown)
    // This is independent of layout mode - used to calculate if sidebar mode CAN work
    React.useEffect(() => {
        // A panel is "open" if user has selected one, regardless of current layout mode
        const panelIsSelected = state === "expanded";
        setSecondarySidebarOpen(panelIsSelected);
    }, [state, setSecondarySidebarOpen]);

    // Track the previous sidebar state to detect user-initiated toggles
    const prevSidebarStateRef = React.useRef<string | undefined>(undefined);
    const autoToggleInProgressRef = React.useRef(false);

    React.useEffect(() => {
        if (primarySidebar?.state) {
            const prevState = prevSidebarStateRef.current;
            const newState = primarySidebar.state;
            const stateChanged = prevState !== newState;
            prevSidebarStateRef.current = newState;

            // Detect if this is a manual toggle (state changed but not by auto-layout)
            const isManualToggle = stateChanged && prevState !== undefined && !autoToggleInProgressRef.current;

            // Always sync the expanded state to context (not just on change)
            // This ensures the ref stays in sync even if initial state differs
            setPrimarySidebarExpanded(newState === "expanded", isManualToggle);
        }
    }, [primarySidebar?.state, setPrimarySidebarExpanded]);

    // Register callbacks for auto-layout to collapse/expand the sidebar
    // Use refs to avoid recreating the callbacks
    const collapseSidebarRef = React.useRef(() => {
        autoToggleInProgressRef.current = true;
        primarySidebar.setOpen(false);
        // Reset flag after state change propagates
        setTimeout(() => { autoToggleInProgressRef.current = false; }, 50);
    });
    const expandSidebarRef = React.useRef(() => {
        autoToggleInProgressRef.current = true;
        primarySidebar.setOpen(true);
        // Reset flag after state change propagates
        setTimeout(() => { autoToggleInProgressRef.current = false; }, 50);
    });
    collapseSidebarRef.current = () => {
        autoToggleInProgressRef.current = true;
        primarySidebar.setOpen(false);
        setTimeout(() => { autoToggleInProgressRef.current = false; }, 50);
    };
    expandSidebarRef.current = () => {
        autoToggleInProgressRef.current = true;
        primarySidebar.setOpen(true);
        setTimeout(() => { autoToggleInProgressRef.current = false; }, 50);
    };

    React.useEffect(() => {
        registerPrimarySidebarControl(
            () => collapseSidebarRef.current(),
            () => expandSidebarRef.current()
        );
    }, [registerPrimarySidebarControl]);

    const contentOffset = showDetailsSidebar
        ? `calc(${primaryOffset ?? "0px"} + ${DETAIL_SIDEBAR_WIDTH} + 6px)`
        : primaryOffset ?? undefined;

    // Calculate dynamic top padding for keyboard
    // Ideal: 1 key height gap between layer selector and keyboard
    // Squeeze: reduce gap when space is tight, continuous adjustment
    const dynamicTopPadding = React.useMemo(() => {
        const idealGap = currentUnitSize; // 1 key height
        const minGap = 8; // Minimum gap in pixels

        // Estimate heights: layer selector ~46px (compact) or ~86px (standard)
        const layerSelectorHeight = showEditorOverlay ? 46 : 86;
        const bottomBarHeight = showBottomPanel ? BOTTOM_PANEL_HEIGHT : 0;

        // Get current keyboard height based on variant
        const kbHeight = keyVariant === 'small'
            ? keyboardHeights.small
            : keyVariant === 'medium'
                ? keyboardHeights.medium
                : keyboardHeights.default;

        // Available space = container - layer selector - keyboard - bottom bar
        const availableSpace = containerHeight - layerSelectorHeight - kbHeight - bottomBarHeight;

        // If plenty of room, use ideal gap (1 key height)
        // If tight, scale down continuously but keep minimum
        if (availableSpace >= idealGap) {
            return idealGap;
        } else if (availableSpace > minGap) {
            return availableSpace;
        } else {
            return minGap;
        }
    }, [currentUnitSize, containerHeight, keyboardHeights, keyVariant, showEditorOverlay, showBottomPanel]);

    // Calculate dynamic bottom panel height to fill remaining vertical space
    const dynamicBottomPanelHeight = React.useMemo(() => {
        if (!showBottomPanel) return BOTTOM_PANEL_HEIGHT;

        const MIN_HEIGHT = 150;
        const MAX_HEIGHT = 400;
        const layerSelectorHeight = 86;
        const topPadding = dynamicTopPadding;

        // Get current keyboard height based on variant
        const kbHeight = keyVariant === 'small'
            ? keyboardHeights.small
            : keyVariant === 'medium'
                ? keyboardHeights.medium
                : keyboardHeights.default;

        // Available = container - layerSelector - topPadding - keyboard
        const available = containerHeight - layerSelectorHeight - topPadding - kbHeight;

        return Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, available));
    }, [showBottomPanel, containerHeight, keyboardHeights, keyVariant, dynamicTopPadding]);

    const contentStyle = React.useMemo<React.CSSProperties>(
        () => ({
            marginLeft: contentOffset,
            transition: "margin-left 320ms cubic-bezier(0.22, 1, 0.36, 1), padding-bottom 300ms ease-in-out",
            willChange: "margin-left, padding-bottom",
            // Add bottom padding when bottom panel is shown
            paddingBottom: showBottomPanel ? dynamicBottomPanelHeight : 0,
        }),
        [contentOffset, showBottomPanel, dynamicBottomPanelHeight]
    );

    return (
        <div className={cn("flex flex-1 h-screen max-w-screen min-w-[850px] p-0", showDetailsSidebar && "bg-white")}>
            <AppSidebar />
            {/* Render SecondarySidebar only in sidebar mode */}
            {useSidebarLayout && <SecondarySidebar />}
            <div
                ref={contentContainerRef}
                className={cn(
                    "relative flex-1 px-4 h-screen max-h-screen flex flex-col max-w-full w-full overflow-hidden bg-kb-gray border-none",
                    isDraggingLayer && "ring-4 ring-inset ring-blue-400 ring-opacity-50 bg-blue-50/10"
                )}
                style={contentStyle}
                onClick={() => clearSelection()}
                onMouseEnter={() => isDraggingLayer && setIsLayerDragOver(true)}
                onMouseLeave={() => setIsLayerDragOver(false)}
                onMouseUp={() => {
                    if (isDraggingLayer && isLayerDragOver) {
                        handleLayerDrop();
                        setIsLayerDragOver(false);
                    }
                }}
            >
                {/* Layer drop indicator - covers entire content area */}
                {isDraggingLayer && (
                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-20">
                        <div className="bg-blue-500/90 text-white px-6 py-3 rounded-lg shadow-lg text-lg font-medium">
                            Drop to place on Layer {selectedLayer}
                        </div>
                    </div>
                )}

                <LayerSelector
                    selectedLayer={selectedLayer}
                    setSelectedLayer={setSelectedLayer}
                    isMultiLayersActive={isMultiLayersActive}
                    onToggleMultiLayers={() => setIsMultiLayersActive(prev => !prev)}
                    isAllTransparencyActive={isAllTransparencyActive}
                    onToggleAllTransparency={handleToggleAllTransparency}
                    layerSpacingAdjust={layerSpacingAdjust}
                    onLayerSpacingChange={setLayerSpacingAdjust}
                />

                <div
                    className="flex-1 overflow-y-auto flex flex-col items-center max-w-full relative"
                    ref={viewsScrollRef}
                >

                    {activePanel === "matrixtester" ? (
                        <MatrixTester />
                    ) : (
                        <>
                            {/* Vertical 3D Guide Lines - now in 2D container to ensure verticality */}
                            {(() => {
                                // Calculate precisely how far down the lines should go
                                // Distance between layers = (KeyboardHeight + 20 padding) - 310 overlap + translateZ(15) projection
                                const useFragmentLayout = keyboardLayout !== SVALBOARD_LAYOUT;
                                let maxYUnits = 0;
                                Object.values(keyboardLayout).forEach((key: any) => {
                                    const yPos = (!useFragmentLayout && key.y >= 6) ? key.y + 0.3 : key.y;
                                    maxYUnits = Math.max(maxYUnits, yPos + key.h);
                                });
                                const zStep = layerSpacingAdjust;
                                const stepYValue = zStep * 0.8192; // 0.8192 is sin(55deg)

                                const viewsToDisplay = renderedViews;

                                const totalViewShiftY = isMultiLayersActive ? (viewsToDisplay.length * stepYValue) : 0;
                                const multiLayerHeaderOffset = 0;

                                return (
                                    <div
                                        className="relative w-full flex flex-col items-center"
                                        style={is3DMode ? {
                                            perspective: '1200px',
                                            transformStyle: 'preserve-3d',
                                            paddingBottom: isMultiLayersActive ? `${totalViewShiftY + 50}px` : undefined,
                                        } : undefined}
                                    >
                                        {/* Vertical 3D Guide Lines - now in 2D container to ensure verticality */}
                                            {is3DMode && isMultiLayersActive && (
                                                <GuideLines
                                                    numLayers={viewsToDisplay.length}
                                                    keyVariant={keyVariant}
                                                    keyboardLayout={keyboardLayout}
                                                    fingerClusterSqueeze={fingerClusterSqueeze}
                                                    stepYValue={stepYValue}
                                                    primaryStackIndex={0}
                                                />
                                            )}
                                        {viewsToDisplay.map((view, index) => (
                                            (() => {
                                                const stackIndex = isMultiLayersActive ? index : 0;
                                                return (
                                            <div key={view.id}
                                                ref={(el) => {
                                                    if (el) {
                                                        const existing = layerViewRefs.current.get(view.selectedLayer);
                                                        if (view.id === "primary" || !existing) {
                                                            layerViewRefs.current.set(view.selectedLayer, el);
                                                        }
                                                    } else {
                                                        layerViewRefs.current.delete(view.selectedLayer);
                                                    }
                                                }}
                                                className="w-full relative"
                                                style={{
                                                    zIndex: (viewsToDisplay.length - index) * 1000,
                                                    transformStyle: is3DMode ? 'preserve-3d' : 'flat',
                                                }}
                                            >
                                                <div className="flex justify-center h-full relative" style={{ transformStyle: is3DMode ? 'preserve-3d' : 'flat' }}>
                                                    <KeyboardViewInstance
                                                        instanceId={view.id}
                                                        selectedLayer={view.selectedLayer}
                                                        setSelectedLayer={(layer) => handleSetViewLayer(view.id, layer)}
                                                        isPrimary={view.id === "primary"}
                                                        hideLayerTabs={isMultiLayersActive && view.id !== "primary"}
                                                        layerActiveState={layerActiveState}
                                                        onToggleLayerOn={handleToggleLayerOn}
                                                        transparencyByLayer={transparencyByLayer}
                                                        onToggleTransparency={handleToggleTransparency}
                                                        showAllLayers={showAllLayers}
                                                        onToggleShowLayers={handleToggleShowLayers}
                                                        isLayerOrderReversed={isLayerOrderReversed}
                                                        onToggleLayerOrder={() => setIsLayerOrderReversed(prev => !prev)}
                                                        isMultiLayersActive={isMultiLayersActive}
                                                        isAllTransparencyActive={isAllTransparencyActive}
                                                        isTransparencyRestoring={isTransparencyRestoring}
                                                        multiLayerHeaderOffset={multiLayerHeaderOffset}
                                                        onRemove={!isMultiLayersActive && view.id !== "primary" ? () => handleRemoveView(view.id) : undefined}
                                                        onGhostNavigate={isMultiLayersActive ? handleGhostNavigate : undefined}
                                                        isRevealing={view.id === revealingViewId}
                                                        isHiding={view.id === hidingViewId}
                                                        stackIndex={stackIndex}
                                                        layerSpacingPx={layerSpacingAdjust}
                                                        baseBadgeOffsetY={baseBadgeOffsetY}
                                                        onBaseBadgeOffsetY={view.id === "primary" ? setBaseBadgeOffsetY : undefined}
                                                    />
                                                </div>
                                            </div>
                                                );
                                            })()
                                        ))}
                                    </div>
                                );
                            })()}
                        </>
                    )}

                    {/* Add View Button */}
                    {!isMultiLayersActive && (
                        <div
                            className="flex items-center pl-5 pb-2 w-full"
                            style={{
                                opacity: hideAddButton ? 0 : 1,
                                transition: hideAddButton ? 'none' : 'opacity 150ms ease-in-out',
                            }}
                        >
                            <Tooltip delayDuration={500}>
                                <TooltipTrigger asChild>
                                    <button
                                        ref={addViewButtonRef}
                                        onClick={handleAddView}
                                        className="p-2 rounded-full transition-colors text-gray-500 hover:text-gray-800 hover:bg-gray-200"
                                        aria-label="Add keyboard layer view"
                                    >
                                        <LayersPlusIcon className="h-5 w-5" />
                                    </button>
                                </TooltipTrigger>
                                <TooltipContent side="right">
                                    Show another layer view
                                </TooltipContent>
                            </Tooltip>
                        </div>
                    )}

                    {/* Flying icon animation (add: plus→minus, remove: minus→plus) */}
                    {flyingIcon && !isMultiLayersActive && (
                        <div
                            className="fixed pointer-events-none"
                            style={{
                                left: flyingIcon.endX !== undefined ? flyingIcon.endX : flyingIcon.startX,
                                top: flyingIcon.endY !== undefined ? flyingIcon.endY : flyingIcon.startY,
                                transition: flyingIcon.endX !== undefined
                                    ? 'left 400ms cubic-bezier(0.42, 0, 0.58, 1), top 400ms cubic-bezier(0.42, 0, 0.58, 1)'
                                    : 'none',
                                zIndex: 40,
                            }}
                            onTransitionEnd={handleFlyingIconEnd}
                        >
                            <div className="p-2">
                                {flyingIcon.iconType === 'plus'
                                    ? <LayersPlusIcon className="h-5 w-5 text-gray-500" />
                                    : <LayersMinusIcon className="h-5 w-5 text-gray-400" />}
                            </div>
                        </div>
                    )}

                    {/* Editor overlay for bottom bar mode - picker tabs + editor */}
                    {useBottomLayout && (
                        <div
                            className={cn(
                                "absolute inset-x-0 bottom-0 z-[60] transition-all duration-300 ease-in-out flex items-end justify-center gap-0 max-h-full",
                                showEditorOverlay ? "opacity-100 pointer-events-auto" : "opacity-0 pointer-events-none"
                            )}
                            onClick={(e) => e.stopPropagation()}
                        >
                            {/* Picker selector tabs - vertical on the left */}
                            <div className="flex-shrink-0 bg-white border-r border-gray-200 shadow-lg self-stretch">
                                <EditorSidePanel
                                    activeTab={pickerMode}
                                    onTabChange={setPickerMode}
                                    showMacros={activePanel !== "macros"}
                                />
                            </div>

                            {/* Editor Panel - minimum height matches picker, can grow for content */}
                            <div className={cn(
                                "bg-kb-gray-medium flex-shrink-0 shadow-[8px_0_24px_rgba(0,0,0,0.15),-2px_0_8px_rgba(0,0,0,0.1)] min-h-[280px] max-h-full overflow-auto self-stretch",
                                activePanel === "overrides" ? "w-[700px]" : "w-[500px]"
                            )}>
                                {itemToEdit !== null && (
                                    <div className="relative">
                                        <button
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                setIsClosingEditor(true);
                                                setTimeout(() => {
                                                    handleCloseEditor();
                                                    setItemToEdit(null);
                                                }, 100);
                                            }}
                                            className="absolute top-4 right-4 p-1 rounded hover:bg-black/10 transition-colors z-10"
                                        >
                                            <X className="h-5 w-5 text-gray-500" />
                                        </button>
                                        <BindingEditorContainer shouldClose={isClosingEditor} inline />
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Controls - bottom left corner for bottom bar mode (same style as sidebar mode) */}
                    {useBottomLayout && !showEditorOverlay && (
                        <div className="absolute bottom-4 left-4 z-10">
                            <EditorControls
                                showInfoPanel={showInfoPanel}
                                setShowInfoPanel={setShowInfoPanel}
                            />
                        </div>
                    )}
                </div>

                {/* Controls - bottom left in sidebar mode only */}
                {
                    !useBottomLayout && (
                        <>
                            {activePanel !== "matrixtester" && (
                                <div className="absolute bottom-9 left-[37px] z-50">
                                    <InfoPanelWidget showInfoPanel={showInfoPanel} setShowInfoPanel={setShowInfoPanel} />
                                </div>
                            )}

                            <div className="absolute bottom-9 right-[37px] flex flex-col items-end gap-1 pointer-events-none">
                                <div className="pointer-events-auto">
                                    <EditorControls
                                        showInfoPanel={showInfoPanel}
                                        setShowInfoPanel={setShowInfoPanel}
                                        showInfoToggle={false}
                                    />
                                </div>
                                {import.meta.env.DEV && (
                                    <div className="text-[10px] font-medium text-slate-400 select-none px-1 pointer-events-auto">
                                        Branch: {gitBranchLabel}
                                    </div>
                                )}
                            </div>
                        </>
                    )
                }
            </div >
            {/* Render BottomPanel at root level so it spans full width */}
            {useBottomLayout && <BottomPanel leftOffset={primaryOffset} pickerMode={pickerMode} height={dynamicBottomPanelHeight} />}

            {/* Picked Key Info Panel Display (Floating near bottom left button) */}
            {
                useBottomLayout && !showEditorOverlay && showInfoPanel && (
                    <div className="absolute bottom-16 left-4 z-50 bg-white text-black shadow-lg rounded-xl p-4 w-[280px] border border-gray-200">
                        <div className="text-sm space-y-1">
                            {(() => {
                                const { hoveredKey, selectedTarget } = useKeyBinding();
                                const { keyboard } = useVial();
                                const target = hoveredKey || selectedTarget;

                                if (!target) {
                                    return (
                                        <p className="text-gray-300 italic text-sm text-center">No key selected</p>
                                    );
                                }

                                const matrixCols = keyboard?.cols || MATRIX_COLS;
                                const pos = (typeof target.row === 'number' && typeof target.col === 'number')
                                    ? (target.row * matrixCols + target.col)
                                    : null;

                                return (
                                    <div className="text-sm space-y-1.5 select-none">
                                        <div className="flex items-baseline gap-2">
                                            <span className="font-bold text-gray-500 text-[10px] uppercase tracking-wider">Keycode:</span>
                                            <span className="font-mono bg-gray-100 px-1.5 py-0.5 rounded text-xs">{target.keycode || "?"}</span>
                                        </div>
                                        {pos !== null && (
                                            <div className="grid grid-cols-2 gap-4 border-t border-gray-100 pt-1.5 mt-1.5">
                                                <div>
                                                    <span className="block font-bold text-gray-500 text-[10px] uppercase tracking-wider">Position:</span>
                                                    <span className="text-xs">R{target.row} C{target.col}</span>
                                                </div>
                                                <div>
                                                    <span className="block font-bold text-gray-500 text-[10px] uppercase tracking-wider">Matrix:</span>
                                                    <span className="text-xs">{pos}</span>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                );
                            })()}
                        </div>
                    </div>
                )
            }


            {/* Paste Layer Dialog */}
            <PasteLayerDialog
                currentLayerName={currentLayerName}
                onConfirm={handlePasteConfirm}
            />
        </div >
    );
};


/**
 * Renders perfectly vertical dotted guide lines connecting key clusters across layers in 3D mode.
 * Rendered in 2D space but aligned with the 3D-projected clusters.
 */
const GuideLines = ({
    numLayers,
    keyVariant,
    keyboardLayout,
    fingerClusterSqueeze,
    stepYValue,
    primaryStackIndex
}: {
    numLayers: number,
    keyVariant: string,
    keyboardLayout: any,
    fingerClusterSqueeze: number,
    stepYValue: number,
    primaryStackIndex: number
}) => {
    const unitSize = keyVariant === 'small' ? 30 : keyVariant === 'medium' ? 45 : 60;
    const keyboardPadding = 16; // matches Keyboard.tsx p-4
    const useFragmentLayout = keyboardLayout !== SVALBOARD_LAYOUT;
    const getYPos = (y: number) => (
        (!useFragmentLayout && y >= 6) ? y + THUMB_OFFSET_U : y
    );

    let layoutMaxX = 0;
    let layoutMaxY = 0;
    Object.values(keyboardLayout).forEach((k: any) => {
        layoutMaxX = Math.max(layoutMaxX, k.x + k.w);
        layoutMaxY = Math.max(layoutMaxY, getYPos(k.y) + k.h);
    });
    const layoutMidline = layoutMaxX / 2;

    const overlayRef = React.useRef<HTMLDivElement | null>(null);
    const [guidePointsPx, setGuidePointsPx] = React.useState<Array<{ x: number; y: number; label: string }>>([]);
    const [svgSize, setSvgSize] = React.useState({ width: 0, height: 0 });

    const findKeyByXY = (x: number, y: number) => {
        let best: { x: number; y: number; w: number; h: number } | null = null;
        let bestDist = Infinity;
        Object.values(keyboardLayout).forEach((k: any) => {
            const dx = Math.abs(k.x - x);
            const dy = Math.abs(k.y - y);
            const dist = dx + dy;
            if (dist < bestDist) {
                bestDist = dist;
                best = { x: k.x, y: k.y, w: k.w, h: k.h };
            }
        });
        return bestDist <= 0.75 ? best : null;
    };

    const clusterTopKeys = [
        { x: 1, y: 1.5, label: "L1" },    // Q
        { x: 3.5, y: 0, label: "L2" },    // W
        { x: 7, y: 0, label: "L3" },      // E
        { x: 9.5, y: 1.5, label: "L4" },  // R
        { x: 13.8, y: 1.5, label: "R1" }, // U
        { x: 16.3, y: 0, label: "R2" },   // I
        { x: 19.8, y: 0, label: "R3" },   // O
        { x: 22.3, y: 1.5, label: "R4" }, // P
    ];

    React.useLayoutEffect(() => {
        const overlayEl = overlayRef.current;
        const keyboardEl = document.querySelector('[data-keyboard-instance="primary"]') as HTMLElement | null;
        if (!overlayEl || !keyboardEl) return;

        const transformEl = (keyboardEl.closest('.keyboard-3d-active') as HTMLElement | null) || keyboardEl;

        const getLayoutOffset = (el: HTMLElement) => {
            let x = 0;
            let y = 0;
            let current: HTMLElement | null = el;
            while (current) {
                x += current.offsetLeft;
                y += current.offsetTop;
                current = current.offsetParent as HTMLElement | null;
            }
            return { x: x - window.scrollX, y: y - window.scrollY };
        };

        const measure = () => {
            const overlayRect = overlayEl.getBoundingClientRect();
            setSvgSize({ width: overlayRect.width, height: overlayRect.height });

            const layoutOffset = getLayoutOffset(transformEl);
            const originStyle = getComputedStyle(transformEl).transformOrigin.split(' ');
            const parseOrigin = (value: string, size: number) => {
                if (value.endsWith('%')) return (parseFloat(value) / 100) * size;
                return parseFloat(value);
            };
            const originX = parseOrigin(originStyle[0], transformEl.offsetWidth);
            const originY = parseOrigin(originStyle[1] || '0px', transformEl.offsetHeight);


            const degToRad = Math.PI / 180;
            const sin45 = Math.sin(45 * degToRad);
            const cos45 = Math.cos(45 * degToRad);
            const sin55 = Math.sin(55 * degToRad);
            const cos55 = Math.cos(55 * degToRad);
            const zStep = stepYValue / sin55;
            const zOffset = primaryStackIndex * zStep;

            const projectPoint = (pxX: number, pxY: number) => {
                const localX = pxX - originX;
                const localY = pxY - originY;
                const z = zOffset;

                // translateZ then rotateZ(-45deg)
                const x1 = (localX * cos45) + (localY * sin45);
                const y1 = (-localX * sin45) + (localY * cos45);

                // rotateX(55deg)
                const y2 = (y1 * cos55) - (z * sin55);
                const x2 = x1;

                return {
                    x: x2 + originX,
                    y: y2 + originY,
                };
            };

            const points: Array<{ x: number; y: number; label: string }> = [];
            const pushProjectedPoint = (label: string, pxX: number, pxY: number) => {
                const projected = projectPoint(pxX, pxY);
                points.push({
                    x: projected.x + layoutOffset.x - overlayRect.left,
                    y: projected.y + layoutOffset.y - overlayRect.top,
                    label,
                });
            };

            const keyToPos = (key: { x: number; y: number; w: number; h: number }) => {
                let xPos = key.x;
                if (!useFragmentLayout && fingerClusterSqueeze > 0) {
                    if (key.x + key.w / 2 < layoutMidline) {
                        xPos = key.x + fingerClusterSqueeze;
                    } else {
                        xPos = key.x - fingerClusterSqueeze;
                    }
                    xPos -= fingerClusterSqueeze;
                }
                const yPos = getYPos(key.y);
                return { x: xPos, y: yPos, w: key.w, h: key.h };
            };

            const addFromKey = (key: { x: number; y: number; w: number; h: number }, side: "top" | "right" | "bottom" | "left", label: string) => {
                const k = keyToPos(key);
                const leftX = keyboardPadding + (k.x * unitSize);
                const rightX = keyboardPadding + ((k.x + k.w) * unitSize);
                const topY = keyboardPadding + (k.y * unitSize);
                const bottomY = keyboardPadding + ((k.y + k.h) * unitSize);

                if (side === "top") {
                    pushProjectedPoint(`${label}-top-1`, leftX, topY);
                    pushProjectedPoint(`${label}-top-2`, rightX, topY);
                } else if (side === "right") {
                    pushProjectedPoint(`${label}-right-1`, rightX, topY);
                    pushProjectedPoint(`${label}-right-2`, rightX, bottomY);
                } else if (side === "bottom") {
                    pushProjectedPoint(`${label}-bottom-1`, leftX, bottomY);
                    pushProjectedPoint(`${label}-bottom-2`, rightX, bottomY);
                } else {
                    pushProjectedPoint(`${label}-left-1`, leftX, topY);
                    pushProjectedPoint(`${label}-left-2`, leftX, bottomY);
                }
            };

            clusterTopKeys.forEach(({ x, y, label }) => {
                const top = findKeyByXY(x, y);
                if (!top) return;
                const right = findKeyByXY(x + 1, y + 1);
                const bottom = findKeyByXY(x, y + 2);
                const left = findKeyByXY(x - 1, y + 1);
                if (top) addFromKey(top, "top", label);
                if (right) addFromKey(right, "right", label);
                if (bottom) addFromKey(bottom, "bottom", label);
                if (left) addFromKey(left, "left", label);
            });

            const getKeyEl = (key: { x: number; y: number }) => {
                const selector = `[data-key-x="${key.x}"][data-key-y="${key.y}"]`;
                return keyboardEl.querySelector(selector) as HTMLElement | null;
            };
            const getQuad = (el: HTMLElement) => {
                const elWithQuads = el as HTMLElement & {
                    getBoxQuads?: (options?: { box?: "margin" | "border" | "padding" | "content" }) => DOMQuad[];
                };
                if (typeof elWithQuads.getBoxQuads === "function") {
                    const quads = elWithQuads.getBoxQuads({ box: "border" });
                    return quads && quads.length ? quads[0] : null;
                }
                return null;
            };
            const quadPoints = (quad: DOMQuad) => [quad.p1, quad.p2, quad.p3, quad.p4];
            const quadEdges = (pts: DOMPoint[]) => ([
                { a: pts[0], b: pts[1] },
                { a: pts[1], b: pts[2] },
                { a: pts[2], b: pts[3] },
                { a: pts[3], b: pts[0] },
            ]).map((e) => ({
                ...e,
                avgX: (e.a.x + e.b.x) / 2,
                avgY: (e.a.y + e.b.y) / 2,
            }));
            const pickTopEdge = (edges: Array<{ a: DOMPoint; b: DOMPoint; avgX: number; avgY: number }>) =>
                edges.reduce((min, e) => (e.avgY < min.avgY ? e : min), edges[0]);
            const orderByX = (a: DOMPoint, b: DOMPoint) => (a.x <= b.x ? { left: a, right: b } : { left: b, right: a });

            const getActualTopEdge = (keyX: number, keyY: number) => {
                const key = findKeyByXY(keyX, keyY);
                if (!key) return null;
                const el = getKeyEl(key);
                const quad = el ? getQuad(el) : null;
                if (!quad) return null;
                const pts = quadPoints(quad);
                const edge = pickTopEdge(quadEdges(pts));
                const { left, right } = orderByX(edge.a, edge.b);
                return {
                    left: { x: left.x - overlayRect.left, y: left.y - overlayRect.top },
                    right: { x: right.x - overlayRect.left, y: right.y - overlayRect.top },
                };
            };

            const l2Actual = getActualTopEdge(3.5, 0); // W
            const r2Actual = getActualTopEdge(16.3, 0); // I
            const calcLeft = points.find((p) => p.label === "L2-top-1");
            const calcRight = points.find((p) => p.label === "R2-top-2");

            if (l2Actual && r2Actual && calcLeft && calcRight) {
                const scaleX = (r2Actual.right.x - l2Actual.left.x) / (calcRight.x - calcLeft.x);
                const dy = l2Actual.left.y - calcLeft.y;
                setGuidePointsPx(points.map((p) => ({
                    ...p,
                    x: l2Actual.left.x + (p.x - calcLeft.x) * scaleX,
                    y: p.y + dy,
                })));
                return;
            }

            setGuidePointsPx(points);
        };

        const handleResize = () => requestAnimationFrame(measure);
        const ro = new ResizeObserver(handleResize);
        ro.observe(overlayEl);
        ro.observe(keyboardEl);
        window.addEventListener('resize', handleResize);
        measure();

        return () => {
            ro.disconnect();
            window.removeEventListener('resize', handleResize);
        };
    }, [keyboardLayout, keyVariant, numLayers, fingerClusterSqueeze, stepYValue, primaryStackIndex, useFragmentLayout, unitSize, layoutMidline, layoutMaxX, layoutMaxY]);

    // Spacing between layers in screen pixels
    const stepY = stepYValue;
    const lineHeight = Math.max((numLayers - 1) * stepY, 1);
    const svgWidth = svgSize.width || 1;
    const svgHeight = (svgSize.height || 1) + lineHeight + 40;

    return (
        <React.Fragment>
            <div ref={overlayRef} className="absolute inset-0 pointer-events-none overflow-visible" style={{ zIndex: 0 }}>
                <svg
                    width={svgWidth}
                    height={svgHeight}
                    style={{ position: "absolute", left: 0, top: 0 }}
                    className="overflow-visible"
                >
                    {(() => {
                        const clusters = new Map<string, { top1?: { x: number; y: number }, top2?: { x: number; y: number } }>();
                        guidePointsPx.forEach((p) => {
                            const parts = p.label.split("-");
                            const cluster = parts[0];
                            const side = parts[1];
                            const idx = parts[2];
                            if (side !== "top") return;
                            const entry = clusters.get(cluster) || {};
                            if (idx === "1") entry.top1 = { x: p.x, y: p.y };
                            if (idx === "2") entry.top2 = { x: p.x, y: p.y };
                            clusters.set(cluster, entry);
                        });

                        return Array.from(clusters.entries()).map(([cluster, pts]) => {
                            if (!pts.top1 || !pts.top2) return null;
                            const bottom1 = { x: pts.top1.x, y: pts.top1.y + lineHeight };
                            const bottom2 = { x: pts.top2.x, y: pts.top2.y + lineHeight };
                            const d = `M ${pts.top1.x} ${pts.top1.y} L ${pts.top2.x} ${pts.top2.y} L ${bottom2.x} ${bottom2.y} L ${bottom1.x} ${bottom1.y} Z`;
                            return (
                                <path
                                    key={`trap-${cluster}`}
                                    d={d}
                                    fill="rgba(148, 163, 184, 0.2)"
                                />
                            );
                        });
                    })()}
                    {false && guidePointsPx.filter(p => !p.label.endsWith("bottom-1")).map((p, i) => {
                        const isDebug = p.label === "L2-top-1" || p.label === "L2-top-2";
                        const debugIdx = p.label.endsWith("-1") ? "1" : "2";
                        return (
                        <g key={`back-${i}`}>
                            <line
                                x1={p.x}
                                y1={p.y}
                                x2={p.x}
                                y2={p.y + lineHeight}
                                stroke="#94a3b8"
                                strokeWidth="1.2"
                                strokeDasharray="1 5"
                                opacity="0.6"
                            />
                            {isDebug && (
                                <>
                                    <circle cx={p.x} cy={p.y} r={5} fill="#ff4fd8" />
                                    <text
                                        x={p.x + 8}
                                        y={p.y - 12}
                                        fill="#ff4fd8"
                                        fontSize="12"
                                        fontWeight={700}
                                        fontFamily='ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace'
                                    >
                                        {debugIdx}
                                    </text>
                                </>
                            )}
                        </g>
                        );
                    })}
                </svg>
            </div>
            <div className="absolute inset-0 pointer-events-none overflow-visible" style={{ zIndex: 30 }}>
                <svg
                    width={svgWidth}
                    height={svgHeight}
                    style={{ position: "absolute", left: 0, top: 0 }}
                    className="overflow-visible"
                >
                    {false && guidePointsPx.filter(p => p.label.endsWith("bottom-1")).map((p, i) => (
                        <g key={`front-${i}`}>
                            <line
                                x1={p.x}
                                y1={p.y}
                                x2={p.x}
                                y2={p.y + lineHeight}
                                stroke="#94a3b8"
                                strokeWidth="1.2"
                                strokeDasharray="1 5"
                                opacity="0.6"
                            />
                        </g>
                    ))}
                </svg>
            </div>
        </React.Fragment>
    );
};

export default EditorLayout;
